package gameplay;

import gameplay.physics.PhysicSimulation;
import lombok.Getter;
import lombok.NoArgsConstructor;

@NoArgsConstructor
public class Character {
    @Getter
    int characterId;

    public CharacterSharedState shared;
    public CharacterCommonState common;

    public Character(int characterId) {
        this.characterId = characterId;
        this.shared = new CharacterSharedState(characterId);
        this.common = new CharacterCommonState();
    }

    public Character(Character base) {
        this.characterId = base.characterId;

        this.shared = base.shared.copy();
        this.common = base.common.copy();
    }

    public String getDisplayName() {
        return "Character #" + characterId;
    }

    public Character copy() {
        return new Character(this);
    }

    public double getX() {
        return shared.x;
    }

    public double getY() {
        return shared.y;
    }

    public boolean isGoingUpByVelocity() {
        return shared.velocityY > 0;
    }

    public boolean isTurnedRight() {
        return shared.walkDirection == WalkDirection.Right;
    }

    public Point getPosition() {
        return new Point(shared.x, shared.y);
    }

    public int getHp() {
        return shared.hp;
    }

    public double getFeetY() {
        return shared.y;
    }

    public double getHeadY() {
        return shared.y + this.getHeight();
    }

    public int getHeight() {
        return CharacterCommonState.HEIGHT;
    }

    public double getRightSideX() {
        return shared.x + CharacterCommonState.WIDTH / 2.0;
    }

    public double getLeftSideX() {
        return shared.x - CharacterCommonState.WIDTH / 2.0;
    }

    /**
     * Before this function can be used, at least one step of physical simulation
     * must be performed on this {@link gameplay.Character} object. This is because
     * it uses information generated by the {@link PhysicalWorld} itself, thus
     * it's not sent over the network.
     *
     * @see PhysicSimulation#perform(gameplay.Character)
     */
    public boolean isOnTheGround() {
        return common.onGround;
    }

    /**
     * Before this function can be used, at least one step of physical simulation
     * must be performed on this {@link gameplay.Character} object. This is because
     * it uses information generated by the {@link PhysicalWorld} itself, thus
     * it's not sent over the network.
     *
     * @see PhysicSimulation#perform(gameplay.Character)
     */
    public boolean isJumping() {
        return common.jumpFrame != -1;
    }

    /**
     * Before this function can be used, at least one step of physical simulation
     * must be performed on this {@link gameplay.Character} object. This is because
     * it uses information generated by the {@link PhysicalWorld} itself, thus
     * it's not sent over the network.
     *
     * @see PhysicSimulation#perform(gameplay.Character)
     */
    public boolean isWalking() {
        return common.runFrame != -1;
    }

    /**
     * Before this function can be used, at least one step of physical simulation
     * must be performed on this {@link gameplay.Character} object. This is because
     * it uses information generated by the {@link PhysicalWorld} itself, thus
     * it's not sent over the network.
     *
     * @see PhysicSimulation#perform(gameplay.Character)
     */
    public boolean isShooting() {
        return common.shootFrame != -1;
    }

    /**
     * Before this function can be used, at least one step of physical simulation
     * must be performed on this {@link gameplay.Character} object. This is because
     * it uses information generated by the {@link PhysicalWorld} itself, thus
     * it's not sent over the network.
     *
     * @see PhysicSimulation#perform(gameplay.Character)
     */
    public boolean isBasicAttack() {
        return common.basicFrame != -1;
    }

    /**
     * Before this function can be used, at least one step of physical simulation
     * must be performed on this {@link gameplay.Character} object. This is because
     * it uses information generated by the {@link PhysicalWorld} itself, thus
     * it's not sent over the network.
     *
     * @see PhysicSimulation#perform(gameplay.Character)
     */
    public boolean isClimbing() {
        return common.climbFrame != -1;
    }
}
